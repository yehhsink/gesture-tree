<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mystery Gift Christmas Tree</title>
    
    <!-- 1. Global CSS Reset -->
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #050505; }
        #root { width: 100%; height: 100%; }
        /* Simple loader to show before React mounts */
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: sans-serif; font-size: 24px; pointer-events: none;
        }
    </style>

    <!-- 2. Dependencies (UMD/Global Builds) -->
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Three.js (Must be the specific build that exposes 'THREE' globally) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Babel Standalone (for in-browser JSX compilation) -->
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
</head>
<body>

    <div id="loader">Loading Christmas Magic...</div>
    <div id="root"></div>

    <!-- 3. Application Script -->
    <script type="text/babel">
        // Access Global Variables explicitly to ensure UMD compliance
        const React = window.React;
        const ReactDOM = window.ReactDOM;
        const THREE = window.THREE;

        const App = () => {
            const mountRef = React.useRef(null);

            React.useEffect(() => {
                // --- SCENE SETUP ---
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                const scene = new THREE.Scene();
                // Dark starry background fog
                scene.fog = new THREE.FogExp2(0x050505, 0.002);

                const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
                camera.position.set(0, 15, 40); // Initial View
                camera.lookAt(0, 10, 0);

                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                mountRef.current.appendChild(renderer.domElement);

                // --- HELPER: TEXTURE GENERATION (No external images) ---
                const createParticleTexture = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 32; canvas.height = 32;
                    const ctx = canvas.getContext('2d');
                    const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
                    grad.addColorStop(0, 'rgba(255,255,255,1)');
                    grad.addColorStop(0.4, 'rgba(255,255,255,0.5)');
                    grad.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, 32, 32);
                    const tex = new THREE.CanvasTexture(canvas);
                    return tex;
                };

                const createTextTexture = (message, colorStr) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 512; 
                    canvas.height = 256;
                    
                    // Background glow
                    ctx.shadowColor = "rgba(0,0,0,0.8)";
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = colorStr;
                    ctx.font = "bold 50px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(message, 256, 128);
                    
                    const tex = new THREE.CanvasTexture(canvas);
                    tex.needsUpdate = true;
                    return tex;
                };

                // --- 1. THE PARTICLE TREE ---
                const particleCount = 2500;
                const geom = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];
                const colorObj = new THREE.Color();

                for(let i = 0; i < particleCount; i++) {
                    // Spiral Logic
                    const angle = Math.random() * Math.PI * 2 * 10; // 10 winds
                    const radius = Math.random() * 10 * (1 - (i / particleCount)); // Wider at bottom
                    const y = (i / particleCount) * 25; // Height up to 25
                    
                    const x = Math.cos(angle * 2 + y) * radius;
                    const z = Math.sin(angle * 2 + y) * radius;

                    positions.push(x, y, z);

                    // Green to Gold Gradient
                    const mixedColor = i > particleCount * 0.9 ? 0xffdd00 : 0x22ff88; 
                    colorObj.setHex(mixedColor);
                    colors.push(colorObj.r, colorObj.g, colorObj.b);
                }

                geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({
                    size: 0.6,
                    vertexColors: true,
                    map: createParticleTexture(),
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                const tree = new THREE.Points(geom, material);
                scene.add(tree);

                // --- 2. BACKGROUND STARS & METEORS ---
                // Static Stars
                const starsGeom = new THREE.BufferGeometry();
                const starPos = [];
                for(let i=0; i<1000; i++) {
                    starPos.push((Math.random()-0.5)*200, (Math.random()-0.5)*200, (Math.random()-0.5)*100 - 50);
                }
                starsGeom.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
                const stars = new THREE.Points(starsGeom, new THREE.PointsMaterial({color: 0xffffff, size: 0.3, transparent: true}));
                scene.add(stars);

                // Meteors (Shooting Stars)
                const meteorCount = 5;
                const meteors = [];
                const meteorGeo = new THREE.BoxGeometry(0.2, 0.2, 8); // Long trail
                const meteorMat = new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0.6});

                for(let i=0; i<meteorCount; i++){
                    const mesh = new THREE.Mesh(meteorGeo, meteorMat);
                    // Start far away
                    mesh.position.set(
                        (Math.random() - 0.5) * 100, 
                        Math.random() * 50 + 20, 
                        (Math.random() - 0.5) * 50 - 40
                    );
                    mesh.rotation.x = Math.PI / 4; // Slanted
                    mesh.rotation.y = Math.PI / 4;
                    scene.add(mesh);
                    meteors.push({ mesh, speed: Math.random() * 0.5 + 0.5 });
                }

                // --- 3. GIFT BOXES (MYSTERY BOXES) ---
                const boxes = [];
                const boxGroup = new THREE.Group();
                scene.add(boxGroup);

                // Game Logic Prep
                let outcomes = Array(12).fill(null).map((_, i) => i < 6 ? 'win' : 'lose');
                // Shuffle outcomes
                outcomes.sort(() => Math.random() - 0.5);

                const boxGeo = new THREE.BoxGeometry(2, 2, 2);
                
                // Texture for boxes (simple colored faces)
                const winMat = new THREE.MeshStandardMaterial({ color: 0xff3333, roughness: 0.3, metalness: 0.6 }); // Red
                const loseMat = new THREE.MeshStandardMaterial({ color: 0x3333ff, roughness: 0.3, metalness: 0.6 }); // Blue (for variety, though hidden initially)
                const baseMat = new THREE.MeshStandardMaterial({ color: 0xd4af37, roughness: 0.2, metalness: 0.8 }); // Gold boxes initially

                // Add Light for boxes
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);
                const pointLight = new THREE.PointLight(0xffddaa, 1, 50);
                pointLight.position.set(10, 20, 10);
                scene.add(pointLight);

                for(let i=0; i<12; i++) {
                    const box = new THREE.Mesh(boxGeo, baseMat.clone());
                    
                    // Position randomly around the base of the tree
                    const angle = (i / 12) * Math.PI * 2;
                    const radius = 8 + Math.random() * 8; // Between 8 and 16 units out
                    box.position.set(Math.cos(angle) * radius, 1, Math.sin(angle) * radius);
                    
                    // Random slight rotation
                    box.rotation.y = Math.random() * Math.PI;

                    box.userData = {
                        id: i,
                        type: outcomes[i], // 'win' or 'lose'
                        opened: false
                    };
                    
                    boxGroup.add(box);
                    boxes.push(box);
                }

                // --- 4. INTERACTION LOGIC (Raycaster) ---
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();

                const onMouseDown = (event) => {
                    // Calculate mouse position in normalized device coordinates (-1 to +1)
                    mouse.x = (event.clientX / width) * 2 - 1;
                    mouse.y = -(event.clientY / height) * 2 + 1;

                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(boxes);

                    if(intersects.length > 0) {
                        const hitBox = intersects[0].object;
                        
                        if(!hitBox.userData.opened) {
                            hitBox.userData.opened = true;

                            // 1. Visual change (open box) - Just change color for simplicity
                            const isWin = hitBox.userData.type === 'win';
                            hitBox.material.color.setHex(isWin ? 0xff0000 : 0x555555);
                            hitBox.scale.set(1.1, 1.1, 1.1); // Pulse up

                            // 2. Spawn Text
                            const msg = isWin ? "Happy Birthday!\nYou Won!" : "Sorry~\nTry Again!";
                            const color = isWin ? "#ffdd00" : "#aaaaaa";
                            
                            const textMap = createTextTexture(msg, color);
                            const spriteMat = new THREE.SpriteMaterial({ map: textMap, transparent: true });
                            const sprite = new THREE.Sprite(spriteMat);
                            
                            // Position text above box
                            sprite.position.copy(hitBox.position);
                            sprite.position.y += 4;
                            sprite.scale.set(10, 5, 1);
                            
                            scene.add(sprite);

                            // Optional: Floating animation for text
                            hitBox.userData.sprite = sprite;
                            hitBox.userData.floatOffset = 0;
                        }
                    }
                };

                // --- 5. CAMERA CONTROLS (Zoom Only) ---
                const onWheel = (event) => {
                    // Adjust camera Z or FOV
                    // Moving Z is safer for simple zoom effect
                    const zoomSpeed = 0.05;
                    let newZ = camera.position.z + event.deltaY * zoomSpeed;
                    
                    // Clamp Zoom
                    newZ = Math.max(15, Math.min(newZ, 60));
                    camera.position.z = newZ;
                };

                window.addEventListener('pointerdown', onMouseDown);
                window.addEventListener('wheel', onWheel);

                // --- 6. ANIMATION LOOP ---
                const clock = new THREE.Clock();

                const animate = () => {
                    requestAnimationFrame(animate);
                    const time = clock.getElapsedTime();

                    // Animate Tree (Shimmer)
                    // We can rotate the tree slightly
                    tree.rotation.y = time * 0.05;

                    // Animate Meteors
                    meteors.forEach(m => {
                        m.mesh.position.x -= m.speed;
                        m.mesh.position.y -= m.speed;
                        m.mesh.position.z -= m.speed * 0.5;

                        // Reset if out of bounds
                        if(m.mesh.position.y < -10) {
                            m.mesh.position.set(
                                50 + Math.random() * 50, 
                                50 + Math.random() * 20, 
                                (Math.random() - 0.5) * 50 - 40
                            );
                        }
                    });

                    // Animate Text (Floating)
                    boxes.forEach(box => {
                        if(box.userData.opened && box.userData.sprite) {
                            box.userData.floatOffset += 0.03;
                            box.userData.sprite.position.y = (box.position.y + 4) + Math.sin(box.userData.floatOffset) * 0.2;
                        }
                    });

                    renderer.render(scene, camera);
                };

                animate();

                // Cleanup
                return () => {
                    window.removeEventListener('pointerdown', onMouseDown);
                    window.removeEventListener('wheel', onWheel);
                    if(mountRef.current) mountRef.current.removeChild(renderer.domElement);
                };

            }, []); // Empty dependency array = run once on mount

            return <div ref={mountRef} style={{width: '100%', height: '100%'}} />;
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
        
        // Hide loader
        document.getElementById('loader').style.display = 'none';
    </script>
</body>
</html>
