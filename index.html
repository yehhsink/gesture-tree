<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Gesture Christmas Tree</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Babel for in-browser JSX/TSX compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      body { margin: 0; padding: 0; overflow: hidden; background-color: #000; touch-action: none; }
      #root { width: 100vw; height: 100vh; }
      /* Custom scrollbar hide */
      ::-webkit-scrollbar { display: none; }
      
      /* Mirror the webcam video for natural interaction */
      .mirror-x { transform: scaleX(-1); }
    </style>

    <!-- Import Map -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "three": "https://esm.sh/three@0.160.0",
    "@mediapipe/tasks-vision": "https://esm.sh/@mediapipe/tasks-vision@0.10.9",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.96.1?external=react,three,@react-three/fiber",
    "lucide-react": "https://esm.sh/lucide-react@0.309.0?external=react",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.14?external=react,react-dom,three",
    "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,three,@react-three/fiber",
    "three-stdlib": "https://esm.sh/three-stdlib@2.28.0?external=three",
  }
}
</script>
</head>
<body>
    <div id="root"></div>

    <!-- Main Application Script -->
    <script type="text/babel" data-type="module" data-presets="react,typescript">
        import React, { createContext, useContext, useRef, useState, useEffect, useMemo, Suspense } from 'react';
        import ReactDOM from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame, useThree } from '@react-three/fiber';
        import { Text, Float, OrbitControls, useTexture } from '@react-three/drei';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';
        import { Camera, Maximize, Minimize, ImagePlus, Hand } from 'lucide-react';
        import { Bloom, EffectComposer } from '@react-three/postprocessing';

        // ----------------------------------------------------------------------
        // CONTEXT & TYPES
        // ----------------------------------------------------------------------
        
        const HandContext = createContext(null);

        const HandProvider = ({ children }) => {
            // Shared mutable ref for high-frequency hand data
            const handRef = useRef({
                x: 0,
                y: 0,
                distance: -1,
                isTracking: false,
            });

            return (
                <HandContext.Provider value={{ handRef }}>
                    {children}
                </HandContext.Provider>
            );
        };

        const useHandData = () => {
            const context = useContext(HandContext);
            if (!context) throw new Error('useHandData must be used within a HandProvider');
            return context;
        };

        // ----------------------------------------------------------------------
        // UTILS: PARTICLE GENERATION
        // ----------------------------------------------------------------------

        const createTreeGeometry = (count, radius, height, primaryColorHex) => {
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);

            const primaryColor = new THREE.Color(primaryColorHex);
            const accentColors = [
                new THREE.Color('#ffb7b2'),
                new THREE.Color('#a8e6cf'),
                new THREE.Color('#ffd3b6'),
                new THREE.Color('#b5eadd'),
                new THREE.Color('#e2f0cb'),
            ];

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                const yRatio = i / count; 
                const y = (yRatio - 0.5) * height;
                const r = radius * (1 - yRatio);
                const angle = yRatio * 50; 
                const randomR = r + (Math.random() - 0.5) * (radius * 0.4); 
                
                const x = Math.cos(angle) * randomR;
                const z = Math.sin(angle) * randomR;

                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;

                // 85% Primary, 15% Accent
                if (Math.random() > 0.15) {
                    colors[i3] = primaryColor.r;
                    colors[i3 + 1] = primaryColor.g;
                    colors[i3 + 2] = primaryColor.b;
                } else {
                    const accent = accentColors[Math.floor(Math.random() * accentColors.length)];
                    colors[i3] = accent.r;
                    colors[i3 + 1] = accent.g;
                    colors[i3 + 2] = accent.b;
                }

                sizes[i] = (Math.random() * 0.5 + 0.5) * (1 - yRatio * 0.5);
            }

            return { positions, colors, sizes };
        };

        const createMeteors = (count) => {
            const positions = new Float32Array(count * 3);
            const speeds = new Float32Array(count);
            
            for(let i=0; i<count; i++) {
                positions[i*3] = (Math.random() - 0.5) * 400;
                positions[i*3+1] = (Math.random() - 0.5) * 400;
                positions[i*3+2] = (Math.random() - 0.5) * 200 - 100; 
                speeds[i] = Math.random() * 2 + 1;
            }
            return { positions, speeds };
        };

        // ----------------------------------------------------------------------
        // COMPONENT: HAND TRACKER
        // ----------------------------------------------------------------------

        const HandTracker = () => {
            const videoRef = useRef(null);
            const { handRef } = useHandData();
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const landmarkerRef = useRef(null);

            useEffect(() => {
                let animationFrameId;

                const setupMediaPipe = async () => {
                    try {
                        const vision = await FilesetResolver.forVisionTasks(
                            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm"
                        );
                        
                        const landmarker = await HandLandmarker.createFromOptions(vision, {
                            baseOptions: {
                                modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                                delegate: "GPU"
                            },
                            runningMode: "VIDEO",
                            numHands: 2
                        });
                        
                        landmarkerRef.current = landmarker;
                        startCamera();
                    } catch (e) {
                        console.error(e);
                        setError("Failed to load hand tracking.");
                        setLoading(false);
                    }
                };

                const startCamera = async () => {
                    if (!videoRef.current) return;
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({
                            video: { facingMode: "user", width: { ideal: 640 }, height: { ideal: 480 } }
                        });
                        videoRef.current.srcObject = stream;
                        videoRef.current.addEventListener('loadeddata', predictWebcam);
                        setLoading(false);
                    } catch (e) {
                        setError("Camera denied.");
                        setLoading(false);
                    }
                };

                const predictWebcam = () => {
                    const video = videoRef.current;
                    const landmarker = landmarkerRef.current;

                    if (video && landmarker) {
                        if (video.currentTime > 0 && !video.paused && !video.ended) {
                            const startTimeMs = performance.now();
                            const results = landmarker.detectForVideo(video, startTimeMs);

                            if (results.landmarks && results.landmarks.length > 0) {
                                let avgX = 0;
                                let avgY = 0;
                                const count = results.landmarks.length;

                                results.landmarks.forEach(hand => {
                                    avgX += hand[0].x;
                                    avgY += hand[0].y;
                                });

                                const normX = (0.5 - (avgX / count)) * 3; 
                                const normY = (0.5 - (avgY / count)) * 2;

                                let distance = -1;
                                if (count === 2) {
                                    const h1 = results.landmarks[0][0];
                                    const h2 = results.landmarks[1][0];
                                    const dx = h1.x - h2.x;
                                    const dy = h1.y - h2.y;
                                    distance = Math.sqrt(dx*dx + dy*dy);
                                }

                                handRef.current = {
                                    x: normX,
                                    y: normY,
                                    distance: distance,
                                    isTracking: true
                                };
                            } else {
                                handRef.current.isTracking = false;
                            }
                        }
                        animationFrameId = requestAnimationFrame(predictWebcam);
                    }
                };

                setupMediaPipe();

                return () => {
                    cancelAnimationFrame(animationFrameId);
                    if (videoRef.current && videoRef.current.srcObject) {
                        videoRef.current.srcObject.getTracks().forEach(t => t.stop());
                    }
                };
            }, [handRef]);

            return (
                <div className="absolute top-4 left-4 z-50 pointer-events-none">
                    <video ref={videoRef} autoPlay playsInline muted className="w-32 h-24 object-cover rounded-lg opacity-30 border border-white/20 mirror-x" />
                    {loading && (
                        <div className="absolute inset-0 flex items-center justify-center bg-black/50 rounded-lg backdrop-blur-sm">
                            <div className="w-6 h-6 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                        </div>
                    )}
                    {error && <div className="absolute top-full mt-2 bg-red-900/80 text-white text-xs p-2 rounded">{error}</div>}
                    {!loading && !error && (
                        <div className="absolute top-1 right-1">
                            <div className={`w-3 h-3 rounded-full ${handRef.current?.isTracking ? 'bg-green-500' : 'bg-red-500'} shadow-[0_0_8px_rgba(0,255,0,0.5)] transition-colors duration-300`} />
                        </div>
                    )}
                </div>
            );
        };

        // ----------------------------------------------------------------------
        // COMPONENT: SCENE CONTENT (3D)
        // ----------------------------------------------------------------------

        const TextureMaterial = ({ url }) => {
            const texture = useTexture(url);
            return <meshStandardMaterial map={texture} roughness={0.3} />;
        };

        const GiftBoxes = ({ textureUrls }) => {
            const gifts = useMemo(() => {
                const items = [];
                for(let i=0; i<12; i++) {
                    const y = (i / 12 - 0.5) * 60;
                    const r = 28 * (1 - i/12) + 5; 
                    const angle = i * 2.5;
                    const x = Math.cos(angle) * r;
                    const z = Math.sin(angle) * r;
                    items.push({ 
                        pos: [x, y, z], 
                        color: ['#ffb7b2', '#a8e6cf', '#ffd3b6', '#ffffff'][i%4] 
                    });
                }
                return items;
            }, []);

            const [hovered, setHover] = useState(null);

            return (
                <>
                    {gifts.map((gift, idx) => {
                        const textureUrl = textureUrls.length > 0 ? textureUrls[idx % textureUrls.length] : null;
                        return (
                        <Float key={idx} speed={2} rotationIntensity={0.5} floatIntensity={0.5}>
                            <group position={gift.pos}>
                                <mesh 
                                    onPointerOver={(e) => { e.stopPropagation(); setHover(idx); }} 
                                    onPointerOut={(e) => { e.stopPropagation(); setHover(null); }}
                                    scale={hovered === idx ? 1.5 : 1}
                                >
                                    <boxGeometry args={[4, 4, 4]} />
                                    {textureUrl ? (
                                        <TextureMaterial url={textureUrl} />
                                    ) : (
                                        <meshStandardMaterial color={gift.color} roughness={0.3} metalness={0.1} />
                                    )}
                                </mesh>
                                <mesh scale={hovered === idx ? 1.52 : 1.02}>
                                    <boxGeometry args={[1, 4.1, 4.1]} />
                                    <meshStandardMaterial color="#fff" />
                                </mesh>
                                <mesh scale={hovered === idx ? 1.52 : 1.02}>
                                    <boxGeometry args={[4.1, 4.1, 1]} />
                                    <meshStandardMaterial color="#fff" />
                                </mesh>
                                {hovered === idx && (
                                     <Text position={[0, 5, 0]} fontSize={2} color="white" anchorX="center" anchorY="middle" outlineWidth={0.1} outlineColor="#000">
                                        {textureUrl ? 'Your Memory' : 'Open Me'}
                                     </Text>
                                )}
                            </group>
                        </Float>
                    )})}
                </>
            )
        };

        const Meteors = () => {
            const count = 20;
            const { positions, speeds } = useMemo(() => createMeteors(count), []);
            const linesRef = useRef(null);

            useFrame((state, delta) => {
                if (!linesRef.current) return;
                linesRef.current.children.forEach((child, i) => {
                    child.position.x -= speeds[i] * 60 * delta;
                    child.position.y -= speeds[i] * 40 * delta;
                    if (child.position.x < -200 || child.position.y < -200) {
                        child.position.x = 200 + Math.random() * 100;
                        child.position.y = 100 + Math.random() * 100;
                    }
                });
            });

            return (
                <group ref={linesRef}>
                    {Array.from({ length: count }).map((_, i) => (
                        <mesh key={i} position={[positions[i*3], positions[i*3+1], positions[i*3+2]]} rotation={[0, 0, Math.PI / 4]}>
                            <planeGeometry args={[15, 0.5]} />
                            <meshBasicMaterial color="#fff" transparent opacity={0.6} side={THREE.DoubleSide} />
                        </mesh>
                    ))}
                </group>
            );
        };

        const SceneContent = ({ primaryColor, textureUrls }) => {
            const { handRef } = useHandData();
            const { camera } = useThree();
            const controlsRef = useRef(null);
            
            const prevDistance = useRef(null);
            const prevPan = useRef(null);
            
            const particleCount = 4500;
            const { positions, colors, sizes } = useMemo(() => 
                createTreeGeometry(particleCount, 35, 90, primaryColor), 
                [primaryColor]
            );
            
            const bufferRef = useRef(null);
            
            useFrame((state) => {
                const { x, y, distance, isTracking } = handRef.current;
                
                if (controlsRef.current) controlsRef.current.enabled = !isTracking;

                if (isTracking) {
                    if (distance > -1) {
                        if (prevDistance.current !== null) {
                            const delta = distance - prevDistance.current;
                            const zoomSpeed = 250; 
                            const target = controlsRef.current ? controlsRef.current.target : new THREE.Vector3(0,0,0);
                            const offset = new THREE.Vector3().subVectors(camera.position, target);
                            let newDist = offset.length() - (delta * zoomSpeed);
                            newDist = Math.max(10, Math.min(newDist, 600));
                            offset.setLength(newDist);
                            camera.position.copy(target).add(offset);
                        }
                        prevDistance.current = distance;
                    } else {
                        prevDistance.current = null;
                    }

                    if (prevPan.current !== null) {
                        const dx = x - prevPan.current.x;
                        const dy = y - prevPan.current.y;
                        const panSpeed = 150; 
                        
                        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                        const up = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);
                        
                        const moveVec = new THREE.Vector3()
                            .addScaledVector(right, -dx * panSpeed)
                            .addScaledVector(up, -dy * panSpeed);
                            
                        camera.position.add(moveVec);
                        if (controlsRef.current) controlsRef.current.target.add(moveVec);
                    }
                    prevPan.current = { x, y };
                } else {
                    prevDistance.current = null;
                    prevPan.current = null;
                }

                if (bufferRef.current) {
                    state.scene.rotation.y += 0.0015;
                }
            });

            return (
                <>
                    <OrbitControls 
                        ref={controlsRef}
                        makeDefault 
                        enableDamping 
                        dampingFactor={0.1}
                        enableRotate={false} 
                        enablePan={true}
                        enableZoom={true}
                        panSpeed={1.0}
                        zoomSpeed={0.8}
                        minDistance={10}
                        maxDistance={800}
                        mouseButtons={{
                            LEFT: THREE.MOUSE.PAN,
                            MIDDLE: THREE.MOUSE.DOLLY,
                            RIGHT: THREE.MOUSE.PAN
                        }}
                    />

                    <ambientLight intensity={0.5} />
                    <pointLight position={[10, 10, 10]} intensity={1.2} />
                    <pointLight position={[-10, 20, -10]} intensity={0.5} color="#b5eadd" />

                    <points>
                        <bufferGeometry ref={bufferRef}>
                            <bufferAttribute attach="attributes-position" count={positions.length / 3} array={positions} itemSize={3} />
                            <bufferAttribute attach="attributes-color" count={colors.length / 3} array={colors} itemSize={3} />
                            <bufferAttribute attach="attributes-size" count={sizes.length} array={sizes} itemSize={1} />
                        </bufferGeometry>
                        <pointsMaterial size={0.8} vertexColors transparent opacity={0.8} sizeAttenuation blending={THREE.AdditiveBlending} depthWrite={false} />
                    </points>

                    <GiftBoxes textureUrls={textureUrls} />
                    <Meteors />
                </>
            );
        };

        // ----------------------------------------------------------------------
        // COMPONENT: UI
        // ----------------------------------------------------------------------

        const UI = ({ primaryColor, setPrimaryColor, isFullscreen, toggleFullscreen, setTextureUrls }) => {
            const fileInputRef = useRef(null);

            const handleFileUpload = (e) => {
                if (e.target.files && e.target.files.length > 0) {
                    const newUrls = Array.from(e.target.files).map((file) => URL.createObjectURL(file));
                    setTextureUrls(newUrls);
                }
            };

            return (
                <div className="absolute inset-0 pointer-events-none flex flex-col justify-between p-6 z-10">
                    <div className="flex justify-between items-start pointer-events-auto">
                        <div className="bg-black/40 backdrop-blur-md p-4 rounded-xl border border-white/10 max-w-xs shadow-lg">
                            <h1 className="text-white font-bold text-lg mb-2 flex items-center gap-2">
                                <Hand size={18} className="text-blue-300"/> Gesture Tree
                            </h1>
                            <div className="text-xs text-gray-300 space-y-2">
                                <p className="flex items-center gap-2"><span className="w-16 font-bold text-white bg-white/10 px-1 rounded text-center">Slide</span> <span>Pan View</span></p>
                                <p className="flex items-center gap-2"><span className="w-16 font-bold text-white bg-white/10 px-1 rounded text-center">Spread</span> <span>Zoom In</span></p>
                                <p className="flex items-center gap-2"><span className="w-16 font-bold text-white bg-white/10 px-1 rounded text-center">Pinch</span> <span>Zoom Out</span></p>
                                <p className="text-white/50 pt-2 border-t border-white/10">Mouse: Drag to Pan, Scroll to Zoom</p>
                            </div>
                        </div>

                        <div className="flex flex-col gap-3">
                            <button onClick={toggleFullscreen} className="p-3 bg-white/10 hover:bg-white/20 rounded-full backdrop-blur-md text-white border border-white/5 shadow-lg">
                                {isFullscreen ? <Minimize size={24} /> : <Maximize size={24} />}
                            </button>
                            <button onClick={() => fileInputRef.current?.click()} className="p-3 bg-blue-500/20 hover:bg-blue-500/40 rounded-full backdrop-blur-md text-blue-200 border border-blue-400/30 shadow-lg relative group">
                                <ImagePlus size={24} />
                            </button>
                            <input ref={fileInputRef} type="file" multiple accept="image/*" className="hidden" onChange={handleFileUpload} />
                        </div>
                    </div>

                    <div className="flex justify-center items-end pointer-events-auto mb-8">
                        <div className="bg-black/40 backdrop-blur-md px-6 py-3 rounded-full border border-white/10 flex items-center gap-4 shadow-xl">
                            <label className="text-white text-sm font-medium">Sparkle Color</label>
                            <div className="relative w-8 h-8 rounded-full overflow-hidden border-2 border-white/50">
                                <input type="color" value={primaryColor} onChange={(e) => setPrimaryColor(e.target.value)} className="absolute -top-1/2 -left-1/2 w-[200%] h-[200%] cursor-pointer p-0 border-0" />
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // ----------------------------------------------------------------------
        // MAIN APP
        // ----------------------------------------------------------------------

        const App = () => {
            const [primaryColor, setPrimaryColor] = useState('#f0f0f0');
            const [isFullscreen, setIsFullscreen] = useState(false);
            const [textureUrls, setTextureUrls] = useState([]);

            const toggleFullscreen = () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                    setIsFullscreen(true);
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                        setIsFullscreen(false);
                    }
                }
            };

            useEffect(() => {
                const handleFsChange = () => setIsFullscreen(!!document.fullscreenElement);
                document.addEventListener('fullscreenchange', handleFsChange);
                return () => document.removeEventListener('fullscreenchange', handleFsChange);
            }, []);

            return (
                <div className="w-full h-full relative bg-gradient-to-b from-gray-900 via-gray-800 to-black overflow-hidden">
                    <HandProvider>
                        <HandTracker />
                        <div className="absolute inset-0 z-0">
                            <Canvas dpr={[1, 2]} gl={{ antialias: false, toneMappingExposure: 1.5 }} camera={{ position: [0, 0, 350], fov: 60, near: 1, far: 1000 }}>
                                <color attach="background" args={['#050510']} />
                                <fog attach="fog" args={['#050510', 50, 500]} />
                                <Suspense fallback={null}>
                                    <SceneContent primaryColor={primaryColor} textureUrls={textureUrls} />
                                </Suspense>
                                <EffectComposer enableNormalPass={false}>
                                    <Bloom luminanceThreshold={0.25} mipmapBlur intensity={1.2} radius={0.5} />
                                </EffectComposer>
                            </Canvas>
                        </div>
                        <UI primaryColor={primaryColor} setPrimaryColor={setPrimaryColor} isFullscreen={isFullscreen} toggleFullscreen={toggleFullscreen} setTextureUrls={setTextureUrls} />
                    </HandProvider>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

